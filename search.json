[{"title":"springboot学习笔记","url":"/2021/05/19/springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"1. Spring Boot概述目标：了解Spring Boot是什么，有什么作用\n小结：\nSpring Boot是一个便捷搭建 基于spring工程的脚手架；作用是帮助开发人员快速搭建大型的spring 项目。简化工程的配置，依赖管理；实现开发人员把时间都集中在业务开发上。\n2. Spring Boot入门目标：能够使用Spring Boot搭建项目\n分析：\n需求：可以在浏览器中访问http://localhost:8080/hello输出一串字符\n实现步骤：\n\n创建工程；\n添加依赖（启动器依赖，spring-boot-starter-web）；\n创建启动类；\n创建处理器Controller；\n测试\n\n小结：\nSpring Boot工程可以通过添加启动器依赖和创建启动引导类实现快速创建web工程。\n\nspring-boot-starter-web默认的应用服务器端口是8080\n\n3. Java代码方式配置目标：可以使用@Value获取配置文件配置项并结合@Bean注册组件到Spring\n分析：\n需求：使用Java代码配置数据库连接池，并可以在处理器中注入并使用\n步骤：\n\n添加依赖；\n创建数据库；\n创建数据库连接参数的配置文件jdbc.properties；\n创建配置类；\n改造处理器类注入数据源并使用\n\n小结：\npackage com.itheima.config;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import javax.sql.DataSource;@Configuration@PropertySource(&quot;classpath:jdbc.properties&quot;)public class JdbcConfig &#123;    @Value(&quot;$&#123;jdbc.url&#125;&quot;)    String url;    @Value(&quot;$&#123;jdbc.driverClassName&#125;&quot;)    String driverClassName;    @Value(&quot;$&#123;jdbc.username&#125;&quot;)    String username;    @Value(&quot;$&#123;jdbc.password&#125;&quot;)    String password;    @Bean    public DataSource dataSource()&#123;        DruidDataSource dataSource = new DruidDataSource();        dataSource.setDriverClassName(driverClassName);        dataSource.setUrl(url);        dataSource.setUsername(username);        dataSource.setPassword(password);        return dataSource;    &#125;&#125;\n\n\n\n4. Spring Boot属性注入方式目标：能够使用@ConfigurationProperties实现Spring Boot配置文件配置项读取和应用\n分析：\n需求：将配置文件中的配置项读取到一个对象中；\n实现：可以使用Spring Boot提供的注解@ConfigurationProperties，该注解可以将Spring Boot的配置文件（默认必须为application.properties或application.yml）中的配置项读取到一个对象中。\n实现步骤：\n\n创建配置项类JdbcProperties类，在该类名上面添加@ConfigurationProperties；\n将jdbc.properties修改名称为application.properties；\n将JdbcProperties对象注入到JdbcConfig；\n测试\n\n小结：\n\n使用@ConfigurationProperties编写配置项类将配置文件中的配置项设置到对象中\n\n@ConfigurationProperties(prefix = &quot;jdbc&quot;)public class JdbcProperties &#123;    private String url;    private String driverClassName;    private String username;    private String password;    public String getUrl() &#123;        return url;    &#125;    public void setUrl(String url) &#123;        this.url = url;    &#125;    public String getDriverClassName() &#123;        return driverClassName;    &#125;    public void setDriverClassName(String driverClassName) &#123;        this.driverClassName = driverClassName;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;&#125;\n\n\n\n\n使用@ConfigurationProperties在方法上面使用\n\n@Bean@ConfigurationProperties(prefix = &quot;jdbc&quot;)public DataSource dataSource() &#123;    return new DruidDataSource();&#125;\n\n\n\n5. 多个yml文件配置目标：可以将多个yml文件在application.yml文件中配置激活\n分析：\nyaml与properties配置文件除了展示形式不相同以外，其它功能和作用都是一样的；在项目中原路的读取方式不需要改变。\n1）yml配置文件的特征：\n\n树状层级结构展示配置项；\n配置项之间如果有关系的话需要分行空两格；\n配置项如果有值的话，那么需要在 :之后空一格再写配置项值；\n\n将application.properties配置文件修改为application.yml的话：\njdbc:  driverClassName: com.mysql.jdbc.Driver  url: jdbc:mysql://127.0.0.1:3306/heima  username: root  password: rootkey:  abc: cba  def:    - g    - h    - j\n\n\n\n2）多个yml配置文件；在spring boot中是被允许的。这些配置文件的名称必须为application-***.yml，并且这些配置文件必须要在application.yml配置文件中激活之后才可以使用。\n3）如果properties和yml配置文件同时存在在spring boot项目中；那么这两类配置文件都有效。在两个配置文件中如果存在同名的配置项的话会以properties文件的为主。\n小结：\n在多个配置文件时，需要将这些文件在application.yml文件中进行激活：\n#激活配置文件;需要指定其它的配置文件名称spring:  profiles:    active: abc,def\n\n\n\n6. 自动配置原理目标：了解Spring Boot项目的配置加载流程\n小结：\n\n在 META-INF\\spring.fatories文件中定义了很多自动配置类；可以根据在pom.xml文件中添加的 启动器依赖自动配置组件\n通过如下流程可以去修改application配置文件，改变自动配置的组件默认参数\n\n\n7. lombok应用目标：使用lombok的注解实现pojo类的简化\n分析：\n使用Spring Boot整合SSM工程；需要使用到数据库数据。\n\n将数据库表数据导入到数据库中（springboot_test）；\n\n编写数据库表对应的实体类；一般情况下需要编写get/set/toString等这些方法会耗时并且会让实体类看起来比较臃肿。可以使用lombok插件对实体类进行简化。\nlombok是一个插件工具类包；提供了一些注解@Data、@Getter等这些注解去简化实体类中的构造方法、get/set等方法的编写。\n\n在IDEA中安装lombok插件；\n添加lombok对应的依赖到项目pom.xml文件；\n改造实体类使用lombok注解\n\n\n\n小结：\n在Bean上使用：@Data ：自动提供getter和setter、hashCode、equals、toString等方法@Getter：自动提供getter方法@Setter：自动提供setter方法@Slf4j：自动在bean中提供log变量，其实用的是slf4j的日志功能。\n8. Spring Boot整合-SpringMVC端口和静态资源目标：可以修改tomcat的端口和访问项目中的静态资源\n分析：\n\n修改tomcat端口\n查询**Properties，设置配置项（前缀+类变量名）到application配置文件中\n\n访问项目中的静态资源\n静态资源放置的位置；放置静态资源并访问这些资源\n\n\n小结：\n\n修改项目tomcat端口：\n\n#tomcat端口server:  port: 80\n\n\n在spring boot项目中静态资源可以放置在如下目录：\n \n\n\n9.Spring Boot整合-SpringMVC拦截器目标：可以在Spring Boot项目中配置自定义SpringMVC拦截器\n分析：\n\n编写拦截器（实现HandlerInterceptor）；\n编写配置类实现 WebMvcConfigurer，在该类中添加各种组件；\n测试\n\n小结：\n可以在spring boot项目中通过配置类添加各种组件；如果要添加拦截器的话：\npackage com.itheima.config;import com.itheima.interceptor.MyInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123;    //注册拦截器    @Bean    public MyInterceptor myInterceptor()&#123;        return new MyInterceptor();    &#125;    //添加拦截器到spring mvc拦截器链    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(myInterceptor()).addPathPatterns(&quot;/*&quot;);    &#125;&#125;\n\n\n\n10. Spring Boot整合-事务和连接池目标：配置Spring Boot自带默认的hikari数据库连接池和使用@Transactional注解进行事务配置\n分析：\n\n事务配置\n\n添加事务相关的启动器依赖，mysql相关依赖；\n编写业务类UserService使用事务注解@Transactional\n\n\n数据库连接池hikari配置\n只需要在application配置文件中指定数据库相关参数\n\n\n小结：\n\n事务配置；只需要添加jdbc启动器依赖\n数据库连接池使用默认的hikari，在配置文件中配置如下：\n\nspring:  datasource:    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql://127.0.0.1:3306/springboot_test    username: root    password: root\n\n\n\n11. Spring Boot整合-Mybatis目标：配置Mybatis在Spring Boot工程中的整合包，设置mybatis的实体类别名，输出执行sql语句配置项\n分析：\n\n添加启动器依赖；\n配置Mybatis：实体类别名包，日志，映射文件等；\n配置MapperScan\n\n小结：\n\n添加mybatis官方对于spring boot的一个启动器\n&lt;!--mybatis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt;  \n配置mybatis\nmybatis:  # 实体类别名包路径  type-aliases-package: com.itheima.pojo  # 映射文件路径  # mapper-locations: classpath:mappers/*.xml  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n设置启动器类中的mapper扫描\n \n\n\n12. Spring Boot整合-通用Mapper目标：配置通用Mapper组件到Spring Boot项目中并使用Mapper接口\n分析：\n通用Mapper：可以实现自动拼接sql语句；所有的mapper都不需要编写任何方法也就是不用编写sql语句。可以提高开发效率。\n\n添加启动器依赖；\n改造UserMapper继承Mapper；\n修改启动引导类Application中的Mapper扫描注解；\n修改User实体类添加jpa注解；\n改造UserService实现业务功能；\n\n小结：\n\n在启动引导类上面的mapper扫描注解 一定要修改为 通用mapper的扫描注解\n\n13. Spring Boot整合测试目标：可以访问处理器对应路径将数据库中的数据根据id查询\n分析：\n\n改造HelloController，注入UserService利用其方法实现查询；\n启动项目进行测试 http://localhost/user/用户id –&gt; http://localhost/user/8\n\n小结：\n修改了HelloController：\n@Autowiredprivate UserService userService;/** * 根据用户id查询用户 * @param id 用户id * @return 用户 */@GetMapping(&quot;/user/&#123;id&#125;&quot;)public User queryById(@PathVariable Long id)&#123;    return userService.queryById(id);&#125;\n\n\n\n14. Spring Boot整合-Junit目标：在Spring Boot项目中使用Junit进行单元测试UserService的方法\n分析：\n\n添加启动器依赖spring-boot-starter-test；\n编写测试类\n\n小结：\n@RunWith(SpringRunner.class)@SpringBootTestpublic class UserServiceTest &#123;    @Autowired    private UserService userService;    @Test    public void queryById() &#123;        User user = userService.queryById(8L);        System.out.println(&quot;user = &quot; + user);    &#125;    @Test    public void saveUser() &#123;        User user = new User();        user.setUserName(&quot;test2&quot;);        user.setName(&quot;test2&quot;);        user.setAge(13);        user.setPassword(&quot;123456&quot;);        user.setSex(1);        user.setCreated(new Date());        userService.saveUser(user);    &#125;&#125;\n\n\n在Spring Boot项目中如果编写测试类则必须要在类上面添加@SpringBootTest\n\n15. Spring Boot整合-redis目标：在Spring Boot项目中使用Junit测试RedisTemplate的使用\n分析：\n\n添加启动器依赖；spring-boot-starter-data-redis\n配置application.yml中修改redis的连接参数；（redis需要启动）\n编写测试类应用RedisTemplate操作redis中的5种数据类型（string/hash/list/set/sorted set）\n\n小结：\n@RunWith(SpringRunner.class)@SpringBootTestpublic class RedisTest &#123;    @Autowired    private RedisTemplate redisTemplate;    @Test    public void test()&#123;        //string 字符串        //redisTemplate.opsForValue().set(&quot;str&quot;, &quot;heima&quot;);        redisTemplate.boundValueOps(&quot;str&quot;).set(&quot;heima&quot;);        System.out.println(&quot;str = &quot; + redisTemplate.opsForValue().get(&quot;str&quot;));        //hash 散列        redisTemplate.boundHashOps(&quot;h_key&quot;).put(&quot;name&quot;, &quot;heima&quot;);        redisTemplate.boundHashOps(&quot;h_key&quot;).put(&quot;age&quot;, 13);        //获取所有域        Set set = redisTemplate.boundHashOps(&quot;h_key&quot;).keys();        System.out.println(&quot; hash散列的所有域：&quot; + set);        //获取所有值        List list = redisTemplate.boundHashOps(&quot;h_key&quot;).values();        System.out.println(&quot; hash散列的所有域的值：&quot; + list);        //list 列表        redisTemplate.boundListOps(&quot;l_key&quot;).leftPush(&quot;c&quot;);        redisTemplate.boundListOps(&quot;l_key&quot;).leftPush(&quot;b&quot;);        redisTemplate.boundListOps(&quot;l_key&quot;).leftPush(&quot;a&quot;);        //获取全部元素        list = redisTemplate.boundListOps(&quot;l_key&quot;).range(0, -1);        System.out.println(&quot; list列表中的所有元素：&quot; + list);        // set 集合        redisTemplate.boundSetOps(&quot;s_key&quot;).add(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);        set = redisTemplate.boundSetOps(&quot;s_key&quot;).members();        System.out.println(&quot; set集合中的所有元素：&quot; + set);        // sorted set 有序集合        redisTemplate.boundZSetOps(&quot;z_key&quot;).add(&quot;a&quot;, 30);        redisTemplate.boundZSetOps(&quot;z_key&quot;).add(&quot;b&quot;, 20);        redisTemplate.boundZSetOps(&quot;z_key&quot;).add(&quot;c&quot;, 10);        set = redisTemplate.boundZSetOps(&quot;z_key&quot;).range(0, -1);        System.out.println(&quot; zset有序集合中的所有元素：&quot; + set);    &#125;&#125;\n\n\n\n16. Spring Boot项目部署目标：将Spring Boot项目使用maven指令打成jar包并运行测试\n分析：\n\n需要添加打包组件将项目中的资源、配置、依赖包打到一个jar包中；可以使用maven的package；\n部署：java -jar 包名\n\n小结：\n\n添加打包组件\n&lt;build&gt;    &lt;plugins&gt;       &lt;!-- 打jar包时如果不配置该插件，打出来的jar包没有清单文件 --&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n部署运行\njava -jar 包名\n\n","categories":["java框架学习"],"tags":["java"]},{"title":"related","url":"/2021/05/19/%E5%A7%BF%E6%80%81%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/","content":"A. 解决视频帧之间的时间依赖和几何一致性的方法employ recurrent neural networks (RNNs) such as Long Short Term Memory (LSTM), Gate Recurrent Unit (GRU) or 3DCNNs to model geometric consistency as well as temporal dependency across video frames.\n使用循环神经网络(RNNs)，如长期记忆(LSTM)，门循环单元(GRU)或3DCNNs来建模几何一致性以及视频帧之间的时间依赖性。\n1. Lstm pose machines使用卷积LSTM捕捉时间和空间线索，并直接预测视频的关键点热图序列。这种基于RNN的方法在人体空间稀疏的情况下更有效，例如在单人场景中具有最小的遮挡。然而，在多人姿态估计中经常出现遮挡的情况下，甚至在单人情况下出现严重遮挡时，极易影响算法的性能。\n2. Combining detection and tracking for human pose estimation in videos.提出了一个3DHRNet (HRNet的扩展，包括时间维度)，用于跨视频帧提取空间和时间特征以估计姿态序列。这个模型已经显示了出色的结果，特别是对于足够长的持续时间的单人序列。\n3. Thin-slicing network: A deep structured model for pose estimation in videos.建议计算每两帧之间的密集光流，并利用附加的基于流的表示来对齐预测。\n4. Flowing convnets for human pose estimation in videos.建议计算每两帧之间的密集光流，并利用附加的基于流的表示来对齐预测。\n5.Learning temporal pose estimation from sparsely-labeled videos提出通过翘曲机制从稀疏标记的视频中学习一个有效的视频姿态检测器\nB. 基于图像的姿态估计1.早期\nHuman pose estimation with iterative error feedback. 通过回归图像特征直接输出骨骼关节坐标\nStacked hourglass networks for human pose estimation.利用概率热图来表示节点位置。\n\n3.Bottom-Up自底向上的方法首先检测个体的身体部位，然后将这些组成部分组装成整个人。\n\nRealtime multi-person 2d pose estimation using part affinity fields. 构建一个自底向上的管道，并利用部件关联字段来捕获不同主体部件之间的成对关系。\nFast multi-person pose estimation using pose residual network. \nPifpaf: Composite fields for human pose estimation.\nCrowdpose: Efficient crowded scenes pose estimation and a new benchmark\n\n4.Top-Down自上而下的方法首先进行人的检测，然后对每个个体进行单人姿态估计。\n\nConvolutional pose machines.提出了一种卷积位姿机的顺序架构，该架构遵循迭代精炼每个网络阶段输出的策略。\nRmpe: Regional multi-person pose estimation.设计一个对称的空间变压器网络，从一个不准确的包围框中提取高质量的单人区域。\nDeep high-resolution representation learning for human pose estimation. 最近的一项工作提出了一个HRNet，它执行多尺度融合来保留高分辨率的特征。这提高了关键热图的空间精度，并在几个基于图像的基准上达到了最先进的水平。\n\n5.Top-Down VS Bottom-Up图像姿态：通过利用鲁棒的人检测器，top-down可以专注于边界盒区域内的联合检测任务，而不必处理自底向上方法所做的大规模变化和将关节分组成人的问题。\n视频姿态：自顶向下的方法在视频上的表现并不好，最近被自底向上的方法[25]所超越。因为在视频中检测人的边界框比在图像中检测要困难得多。虽然图像经常捕捉人们“摆姿势”，视频固有地包含非典型类型的遮挡、视点、运动模糊和姿态，使目标检测器偶尔失败\nC. 视频级的时间信息1.动机[Deep Dual Consecutive Network for Human Pose Estimation 3.1]1)尽管现有的姿态估计方法(如[33,12])在视频上的性能下降，但我们观察到，它们的预测仍然为逼近关键点的空间位置提供了有用的信息。\n2)时间一致性，即个体的姿态不会在很少的帧间隔(通常是1/60到1/25秒)中经历戏剧性和突然的变化。\n2.任务多人人体姿态跟踪是检测所有视频帧中所有人的身体关节并随着时间正确连接的双重任务。\n","categories":["姿态估计"],"tags":["神经网络 深度学习"]}]