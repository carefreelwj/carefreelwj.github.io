[{"title":"springboot学习笔记","url":"/2021/05/19/springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"1. Spring Boot概述目标：了解Spring Boot是什么，有什么作用\n小结：\nSpring Boot是一个便捷搭建 基于spring工程的脚手架；作用是帮助开发人员快速搭建大型的spring 项目。简化工程的配置，依赖管理；实现开发人员把时间都集中在业务开发上。\n2. Spring Boot入门目标：能够使用Spring Boot搭建项目\n分析：\n需求：可以在浏览器中访问http://localhost:8080/hello输出一串字符\n实现步骤：\n\n创建工程；\n添加依赖（启动器依赖，spring-boot-starter-web）；\n创建启动类；\n创建处理器Controller；\n测试\n\n小结：\nSpring Boot工程可以通过添加启动器依赖和创建启动引导类实现快速创建web工程。\n\nspring-boot-starter-web默认的应用服务器端口是8080\n\n3. Java代码方式配置目标：可以使用@Value获取配置文件配置项并结合@Bean注册组件到Spring\n分析：\n需求：使用Java代码配置数据库连接池，并可以在处理器中注入并使用\n步骤：\n\n添加依赖；\n创建数据库；\n创建数据库连接参数的配置文件jdbc.properties；\n创建配置类；\n改造处理器类注入数据源并使用\n\n小结：\npackage com.itheima.config;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import javax.sql.DataSource;@Configuration@PropertySource(&quot;classpath:jdbc.properties&quot;)public class JdbcConfig &#123;    @Value(&quot;$&#123;jdbc.url&#125;&quot;)    String url;    @Value(&quot;$&#123;jdbc.driverClassName&#125;&quot;)    String driverClassName;    @Value(&quot;$&#123;jdbc.username&#125;&quot;)    String username;    @Value(&quot;$&#123;jdbc.password&#125;&quot;)    String password;    @Bean    public DataSource dataSource()&#123;        DruidDataSource dataSource = new DruidDataSource();        dataSource.setDriverClassName(driverClassName);        dataSource.setUrl(url);        dataSource.setUsername(username);        dataSource.setPassword(password);        return dataSource;    &#125;&#125;\n\n\n\n4. Spring Boot属性注入方式目标：能够使用@ConfigurationProperties实现Spring Boot配置文件配置项读取和应用\n分析：\n需求：将配置文件中的配置项读取到一个对象中；\n实现：可以使用Spring Boot提供的注解@ConfigurationProperties，该注解可以将Spring Boot的配置文件（默认必须为application.properties或application.yml）中的配置项读取到一个对象中。\n实现步骤：\n\n创建配置项类JdbcProperties类，在该类名上面添加@ConfigurationProperties；\n将jdbc.properties修改名称为application.properties；\n将JdbcProperties对象注入到JdbcConfig；\n测试\n\n小结：\n\n使用@ConfigurationProperties编写配置项类将配置文件中的配置项设置到对象中\n\n@ConfigurationProperties(prefix = &quot;jdbc&quot;)public class JdbcProperties &#123;    private String url;    private String driverClassName;    private String username;    private String password;    public String getUrl() &#123;        return url;    &#125;    public void setUrl(String url) &#123;        this.url = url;    &#125;    public String getDriverClassName() &#123;        return driverClassName;    &#125;    public void setDriverClassName(String driverClassName) &#123;        this.driverClassName = driverClassName;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;&#125;\n\n\n\n\n使用@ConfigurationProperties在方法上面使用\n\n@Bean@ConfigurationProperties(prefix = &quot;jdbc&quot;)public DataSource dataSource() &#123;    return new DruidDataSource();&#125;\n\n\n\n5. 多个yml文件配置目标：可以将多个yml文件在application.yml文件中配置激活\n分析：\nyaml与properties配置文件除了展示形式不相同以外，其它功能和作用都是一样的；在项目中原路的读取方式不需要改变。\n1）yml配置文件的特征：\n\n树状层级结构展示配置项；\n配置项之间如果有关系的话需要分行空两格；\n配置项如果有值的话，那么需要在 :之后空一格再写配置项值；\n\n将application.properties配置文件修改为application.yml的话：\njdbc:  driverClassName: com.mysql.jdbc.Driver  url: jdbc:mysql://127.0.0.1:3306/heima  username: root  password: rootkey:  abc: cba  def:    - g    - h    - j\n\n\n\n2）多个yml配置文件；在spring boot中是被允许的。这些配置文件的名称必须为application-***.yml，并且这些配置文件必须要在application.yml配置文件中激活之后才可以使用。\n3）如果properties和yml配置文件同时存在在spring boot项目中；那么这两类配置文件都有效。在两个配置文件中如果存在同名的配置项的话会以properties文件的为主。\n小结：\n在多个配置文件时，需要将这些文件在application.yml文件中进行激活：\n#激活配置文件;需要指定其它的配置文件名称spring:  profiles:    active: abc,def\n\n\n\n6. 自动配置原理目标：了解Spring Boot项目的配置加载流程\n小结：\n\n在 META-INF\\spring.fatories文件中定义了很多自动配置类；可以根据在pom.xml文件中添加的 启动器依赖自动配置组件\n通过如下流程可以去修改application配置文件，改变自动配置的组件默认参数\n\n\n7. lombok应用目标：使用lombok的注解实现pojo类的简化\n分析：\n使用Spring Boot整合SSM工程；需要使用到数据库数据。\n\n将数据库表数据导入到数据库中（springboot_test）；\n\n编写数据库表对应的实体类；一般情况下需要编写get/set/toString等这些方法会耗时并且会让实体类看起来比较臃肿。可以使用lombok插件对实体类进行简化。\nlombok是一个插件工具类包；提供了一些注解@Data、@Getter等这些注解去简化实体类中的构造方法、get/set等方法的编写。\n\n在IDEA中安装lombok插件；\n添加lombok对应的依赖到项目pom.xml文件；\n改造实体类使用lombok注解\n\n\n\n小结：\n在Bean上使用：@Data ：自动提供getter和setter、hashCode、equals、toString等方法@Getter：自动提供getter方法@Setter：自动提供setter方法@Slf4j：自动在bean中提供log变量，其实用的是slf4j的日志功能。\n8. Spring Boot整合-SpringMVC端口和静态资源目标：可以修改tomcat的端口和访问项目中的静态资源\n分析：\n\n修改tomcat端口\n查询**Properties，设置配置项（前缀+类变量名）到application配置文件中\n\n访问项目中的静态资源\n静态资源放置的位置；放置静态资源并访问这些资源\n\n\n小结：\n\n修改项目tomcat端口：\n\n#tomcat端口server:  port: 80\n\n\n在spring boot项目中静态资源可以放置在如下目录：\n \n\n\n9.Spring Boot整合-SpringMVC拦截器目标：可以在Spring Boot项目中配置自定义SpringMVC拦截器\n分析：\n\n编写拦截器（实现HandlerInterceptor）；\n编写配置类实现 WebMvcConfigurer，在该类中添加各种组件；\n测试\n\n小结：\n可以在spring boot项目中通过配置类添加各种组件；如果要添加拦截器的话：\npackage com.itheima.config;import com.itheima.interceptor.MyInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123;    //注册拦截器    @Bean    public MyInterceptor myInterceptor()&#123;        return new MyInterceptor();    &#125;    //添加拦截器到spring mvc拦截器链    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(myInterceptor()).addPathPatterns(&quot;/*&quot;);    &#125;&#125;\n\n\n\n10. Spring Boot整合-事务和连接池目标：配置Spring Boot自带默认的hikari数据库连接池和使用@Transactional注解进行事务配置\n分析：\n\n事务配置\n\n添加事务相关的启动器依赖，mysql相关依赖；\n编写业务类UserService使用事务注解@Transactional\n\n\n数据库连接池hikari配置\n只需要在application配置文件中指定数据库相关参数\n\n\n小结：\n\n事务配置；只需要添加jdbc启动器依赖\n数据库连接池使用默认的hikari，在配置文件中配置如下：\n\nspring:  datasource:    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql://127.0.0.1:3306/springboot_test    username: root    password: root\n\n\n\n11. Spring Boot整合-Mybatis目标：配置Mybatis在Spring Boot工程中的整合包，设置mybatis的实体类别名，输出执行sql语句配置项\n分析：\n\n添加启动器依赖；\n配置Mybatis：实体类别名包，日志，映射文件等；\n配置MapperScan\n\n小结：\n\n添加mybatis官方对于spring boot的一个启动器\n&lt;!--mybatis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt;  \n配置mybatis\nmybatis:  # 实体类别名包路径  type-aliases-package: com.itheima.pojo  # 映射文件路径  # mapper-locations: classpath:mappers/*.xml  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n设置启动器类中的mapper扫描\n \n\n\n12. Spring Boot整合-通用Mapper目标：配置通用Mapper组件到Spring Boot项目中并使用Mapper接口\n分析：\n通用Mapper：可以实现自动拼接sql语句；所有的mapper都不需要编写任何方法也就是不用编写sql语句。可以提高开发效率。\n\n添加启动器依赖；\n改造UserMapper继承Mapper；\n修改启动引导类Application中的Mapper扫描注解；\n修改User实体类添加jpa注解；\n改造UserService实现业务功能；\n\n小结：\n\n在启动引导类上面的mapper扫描注解 一定要修改为 通用mapper的扫描注解\n\n13. Spring Boot整合测试目标：可以访问处理器对应路径将数据库中的数据根据id查询\n分析：\n\n改造HelloController，注入UserService利用其方法实现查询；\n启动项目进行测试 http://localhost/user/用户id –&gt; http://localhost/user/8\n\n小结：\n修改了HelloController：\n@Autowiredprivate UserService userService;/** * 根据用户id查询用户 * @param id 用户id * @return 用户 */@GetMapping(&quot;/user/&#123;id&#125;&quot;)public User queryById(@PathVariable Long id)&#123;    return userService.queryById(id);&#125;\n\n\n\n14. Spring Boot整合-Junit目标：在Spring Boot项目中使用Junit进行单元测试UserService的方法\n分析：\n\n添加启动器依赖spring-boot-starter-test；\n编写测试类\n\n小结：\n@RunWith(SpringRunner.class)@SpringBootTestpublic class UserServiceTest &#123;    @Autowired    private UserService userService;    @Test    public void queryById() &#123;        User user = userService.queryById(8L);        System.out.println(&quot;user = &quot; + user);    &#125;    @Test    public void saveUser() &#123;        User user = new User();        user.setUserName(&quot;test2&quot;);        user.setName(&quot;test2&quot;);        user.setAge(13);        user.setPassword(&quot;123456&quot;);        user.setSex(1);        user.setCreated(new Date());        userService.saveUser(user);    &#125;&#125;\n\n\n在Spring Boot项目中如果编写测试类则必须要在类上面添加@SpringBootTest\n\n15. Spring Boot整合-redis目标：在Spring Boot项目中使用Junit测试RedisTemplate的使用\n分析：\n\n添加启动器依赖；spring-boot-starter-data-redis\n配置application.yml中修改redis的连接参数；（redis需要启动）\n编写测试类应用RedisTemplate操作redis中的5种数据类型（string/hash/list/set/sorted set）\n\n小结：\n@RunWith(SpringRunner.class)@SpringBootTestpublic class RedisTest &#123;    @Autowired    private RedisTemplate redisTemplate;    @Test    public void test()&#123;        //string 字符串        //redisTemplate.opsForValue().set(&quot;str&quot;, &quot;heima&quot;);        redisTemplate.boundValueOps(&quot;str&quot;).set(&quot;heima&quot;);        System.out.println(&quot;str = &quot; + redisTemplate.opsForValue().get(&quot;str&quot;));        //hash 散列        redisTemplate.boundHashOps(&quot;h_key&quot;).put(&quot;name&quot;, &quot;heima&quot;);        redisTemplate.boundHashOps(&quot;h_key&quot;).put(&quot;age&quot;, 13);        //获取所有域        Set set = redisTemplate.boundHashOps(&quot;h_key&quot;).keys();        System.out.println(&quot; hash散列的所有域：&quot; + set);        //获取所有值        List list = redisTemplate.boundHashOps(&quot;h_key&quot;).values();        System.out.println(&quot; hash散列的所有域的值：&quot; + list);        //list 列表        redisTemplate.boundListOps(&quot;l_key&quot;).leftPush(&quot;c&quot;);        redisTemplate.boundListOps(&quot;l_key&quot;).leftPush(&quot;b&quot;);        redisTemplate.boundListOps(&quot;l_key&quot;).leftPush(&quot;a&quot;);        //获取全部元素        list = redisTemplate.boundListOps(&quot;l_key&quot;).range(0, -1);        System.out.println(&quot; list列表中的所有元素：&quot; + list);        // set 集合        redisTemplate.boundSetOps(&quot;s_key&quot;).add(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);        set = redisTemplate.boundSetOps(&quot;s_key&quot;).members();        System.out.println(&quot; set集合中的所有元素：&quot; + set);        // sorted set 有序集合        redisTemplate.boundZSetOps(&quot;z_key&quot;).add(&quot;a&quot;, 30);        redisTemplate.boundZSetOps(&quot;z_key&quot;).add(&quot;b&quot;, 20);        redisTemplate.boundZSetOps(&quot;z_key&quot;).add(&quot;c&quot;, 10);        set = redisTemplate.boundZSetOps(&quot;z_key&quot;).range(0, -1);        System.out.println(&quot; zset有序集合中的所有元素：&quot; + set);    &#125;&#125;\n\n\n\n16. Spring Boot项目部署目标：将Spring Boot项目使用maven指令打成jar包并运行测试\n分析：\n\n需要添加打包组件将项目中的资源、配置、依赖包打到一个jar包中；可以使用maven的package；\n部署：java -jar 包名\n\n小结：\n\n添加打包组件\n&lt;build&gt;    &lt;plugins&gt;       &lt;!-- 打jar包时如果不配置该插件，打出来的jar包没有清单文件 --&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n部署运行\njava -jar 包名\n\n","categories":["java框架学习"],"tags":["java"]},{"title":"related","url":"/2021/05/19/%E5%A7%BF%E6%80%81%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/","content":"A. 解决视频帧之间的时间依赖和几何一致性的方法employ recurrent neural networks (RNNs) such as Long Short Term Memory (LSTM), Gate Recurrent Unit (GRU) or 3DCNNs to model geometric consistency as well as temporal dependency across video frames.\n使用循环神经网络(RNNs)，如长期记忆(LSTM)，门循环单元(GRU)或3DCNNs来建模几何一致性以及视频帧之间的时间依赖性。\n1. Lstm pose machines使用卷积LSTM捕捉时间和空间线索，并直接预测视频的关键点热图序列。这种基于RNN的方法在人体空间稀疏的情况下更有效，例如在单人场景中具有最小的遮挡。然而，在多人姿态估计中经常出现遮挡的情况下，甚至在单人情况下出现严重遮挡时，极易影响算法的性能。\n2. Combining detection and tracking for human pose estimation in videos.提出了一个3DHRNet (HRNet的扩展，包括时间维度)，用于跨视频帧提取空间和时间特征以估计姿态序列。这个模型已经显示了出色的结果，特别是对于足够长的持续时间的单人序列。\n3. Thin-slicing network: A deep structured model for pose estimation in videos.建议计算每两帧之间的密集光流，并利用附加的基于流的表示来对齐预测。\n4. Flowing convnets for human pose estimation in videos.建议计算每两帧之间的密集光流，并利用附加的基于流的表示来对齐预测。\n5.Learning temporal pose estimation from sparsely-labeled videos提出通过翘曲机制从稀疏标记的视频中学习一个有效的视频姿态检测器\nB. 基于图像的姿态估计1.早期\nHuman pose estimation with iterative error feedback. 通过回归图像特征直接输出骨骼关节坐标\nStacked hourglass networks for human pose estimation.利用概率热图来表示节点位置。\n\n3.Bottom-Up自底向上的方法首先检测个体的身体部位，然后将这些组成部分组装成整个人。\n\nRealtime multi-person 2d pose estimation using part affinity fields. 构建一个自底向上的管道，并利用部件关联字段来捕获不同主体部件之间的成对关系。\nFast multi-person pose estimation using pose residual network. \nPifpaf: Composite fields for human pose estimation.\nCrowdpose: Efficient crowded scenes pose estimation and a new benchmark\n\n4.Top-Down自上而下的方法首先进行人的检测，然后对每个个体进行单人姿态估计。\n\nConvolutional pose machines.提出了一种卷积位姿机的顺序架构，该架构遵循迭代精炼每个网络阶段输出的策略。\nRmpe: Regional multi-person pose estimation.设计一个对称的空间变压器网络，从一个不准确的包围框中提取高质量的单人区域。\nDeep high-resolution representation learning for human pose estimation. 最近的一项工作提出了一个HRNet，它执行多尺度融合来保留高分辨率的特征。这提高了关键热图的空间精度，并在几个基于图像的基准上达到了最先进的水平。\n\n5.Top-Down VS Bottom-Up图像姿态：通过利用鲁棒的人检测器，top-down可以专注于边界盒区域内的联合检测任务，而不必处理自底向上方法所做的大规模变化和将关节分组成人的问题。\n视频姿态：自顶向下的方法在视频上的表现并不好，最近被自底向上的方法[25]所超越。因为在视频中检测人的边界框比在图像中检测要困难得多。虽然图像经常捕捉人们“摆姿势”，视频固有地包含非典型类型的遮挡、视点、运动模糊和姿态，使目标检测器偶尔失败\nC. 视频级的时间信息1.动机[Deep Dual Consecutive Network for Human Pose Estimation 3.1]1)尽管现有的姿态估计方法(如[33,12])在视频上的性能下降，但我们观察到，它们的预测仍然为逼近关键点的空间位置提供了有用的信息。\n2)时间一致性，即个体的姿态不会在很少的帧间隔(通常是1/60到1/25秒)中经历戏剧性和突然的变化。\n2.任务多人人体姿态跟踪是检测所有视频帧中所有人的身体关节并随着时间正确连接的双重任务。\n","categories":["姿态估计"],"tags":["神经网络 深度学习"]},{"title":"摄像头API调研","url":"/2021/05/20/%E6%91%84%E5%83%8F%E5%A4%B4API%E8%B0%83%E7%A0%94/","content":"1.华为云视频接入服务该服务提供实时视频数据接入功能，包括摄像头视频数据采集、实时数据分发和视频数据转储等能力。借助视频接入服务，您可以与华为云视频分析服务集成，快速构建基于实时视频数据的智能分析应用。\na.视频接入服务视频接入服务（Video Ingestion Service，简称VIS）是华为云提供的实时视频数据接入服务，提供了摄像头视频数据采集、实时数据分发和视频数据转储等能力。借助视频接入服务，您可以与华为云视频分析服务集成，快速构建基于实时视频数据的智能分析应用。\n\n视频接入服务支持一下类型：\n\n视频流：支持RTMP和HTTP-FLV类型的视频流，视频流编码格式支持H264。\n设备：支持GB28181摄像设备接入，视频流编码格式支持H264、H265。\n\n使用场景广泛，包括智慧园区监控、智慧城市安防\n智慧园区监控园区大量使用门禁闸机、摄像头等设备实现安全管理，VIS提供了便捷的视频流管理，与华为EI视频分析服务（Video Analysis Service，VAS）对接，助力智慧园区应用的开发和运维。\n\n便捷易用：快速建立界面可视化的多路视频流管理。\n多协议支持：通过GB28181、RTMP协议自动收集和传输视频流数据。\nAI应用：利用人脸识别、视频分析服务实现智慧园区应用。\n\n\n智慧城市安防VIS高效收集和传输城市安防产生的大量视频流数据，持久化存储，并与视频分析服务对接，实现快速分析处理。\n\n多协议支持：通过GB28181协议实现摄像设备管理、视频流收集传输。\nAI应用：使用人脸识别、视频分析、ModelArts服务进行智能分析处理。\n\n\nb.API概览1.视频流管理\n\n创建视频流：该接口用于创建视频流。\n更新视频流：该接口用于更新视频流的详情，包括RTMP以及HTTP-FLV类型视频流。对于GB28181设备自动关联的视频流，不能通过该接口进行更新。\n删除视频流：此接口用于删除指定视频流。\n更新转储信息：此接口用于更新视频转储信息。创建的视频流默认没有转储信息，即视频数据不会保存。更新转储信息后可以将视频流保存到指定的存储媒介，如OBS。后续用户可以从OBS上获取到转储的视频。\n获取视频流信息：此接口用于获取指定视频流的详细信息。\n获取视频流列表：此接口用于获取所有视频流的详细信息。\n获取视频流地址：此接口用于获取指定视频流的地址。该地址用于进行视频流推流或者拉流。\n\n2.设备指标统计\n\n获取曾经上线设备列表:该接口用于获取曾经上线的GB28181设备列表，即只要上线过的设备信息都会显示。\n获取新上线设备列表:该接口用于获取今天新上线（即之前没有上线记录）的GB28181设备列表。\n获取视频包接收率:该接口用于获取当天有视频接入的GB28181设备的平均视频包接受率的列表。\n\n2. 海康威视摄像机的二次开发设备必须满足的要求：\n\n支持二次开发\n支持无线联网\n像素能看\n价钱合适\n\n综合以上指标最后选定：DS-2DC2204IW-DE3/W\n\na. 摄像头的激活新购买的设备需要通过 SADP工具 激活。\n激活的过程：\n设备上电，并连接局域网下载 SADP工具，并安装在同一个局域网的电脑上，打开工具，搜索到的设备是“未激活”状态。输入新密码、确认密码，点击 激活，激活成功后，设备状态变为“激活”状态，并且可以修改设备的网络参数(IP，PORT) 设备已经激活完毕，并且设备的IP、端口、用户名(默认用户是 admin)、密码均已设置完毕。\nb. 集成 SDK 开发海康设备的SDK是通过网络的方式访问设备，需要用到设备激活过程中设置的参数：IP、端口、用户名、密码、主动注册登录设备\n海康威视的设备能力，按照设备类型对外开放，现阶段（2020-9）按照设备类型对外开放的接口，包括：AI 摄像机、通用摄像机、出入口产品、门禁产品\nc.SDK 接口的主要调用流程\n其中虚线框的流程是可选部分，不会影响其他流程和模块的功能使用。按实现功能的不同可以分成十个模块，实现每个模块的功能时初始化SDK、用户注册设备、注销设备和释放SDK资源这4个流程是必不可少的。\n\n初始化 SDK：对整个网络SDK系统的初始化、内存分配等操作。\n设置连接超时时间：可选，用于设置SDK中的网络连接超时时间，用户可以根据自己的需要设置该值，在不调用此接口设置超时时间的情况下，将采用SDK中的默认值。\n设置接收异常消息的回调函数：由于SDK中大部分模块的功能都是由异步模式实现，所以可以使用此接口接收预览、报警、回放、透明通道和语音对讲等模块发生的异常信息。用户可以在初始化SDK后就设置该回调函数，在应用层对各个模块异常消息的接收和处理。从解析服务器获得设备的IP地址：该接口提供一种在仅知道设备名称（或者设备域名）和序列号的情况下，从解析服务器（IP Server 或者 DDNS Dynamic Domain Name Server，动态域名服务）获得设备IP地址的方法。\n用户注册设备：实现用户的注册功能，注册成功后返回的用户ID作为其他功能操作的唯一标识，SDK允许最大注册个数为2048个。就设备而言，V3.0以上版本支持的设备允许有32个注册用户名，而且同时最多允许128个用户注册；V3.0一下版本支持的设备允许有16个注册用户名；而且同时最多允许128个用户注册。预览模块：从设备取实时码流，解码显示以及播放控制、抓图等功能。回放和下载模块：可以通过按时间和文件名的方式远程回放或者下载设备的录像文件，后续可以进行解码或存储。同时还支持断点续传功能。\n参数配置模块：设置和获取设备参数，主要包括设备参数、网络参数、通道压缩参数、串口参数、报警参数、异常参数、交易信息和用户配置等参数。远程设备维护模块：实现关闭设备、重启设备、恢复默认值、远程硬盘格式化、远程升级和配置文件导入/导出等维护工作。\n语音对讲转发模块：实现和设备的语音数据对讲和语音数据获取，音频编码格式指定。\n报警模块：处理设备上传的各种报警信号。报警分为”布防“和”监听“两种方式，在采用监听方式并且不需要获取用户ID的情况下，报警模块可以无需进行”用户注册“操作步骤。\n透明通道模块：透明通道是将IP数据报文解析后直接发送到串行口的一种技术。实际上起到了沿伸串行设备控制距离的作用。可利用IP网络控制多种串行设备，如控制解码器、矩阵、报警主机、门禁、仪器仪表等串行设备，对用户来说，只看到了点对点的传输，无须关心网络传输的过程，所以称为串口透明通道。SDK提供485和232串口作为透明通道功能，其中要将232作为透明通道使用，首先必须在232串口的配置信息中将工作模式选为透明通道，这样232串口才可作为透明通道使用。\n云台控制模块：实现对云台的基本操作、预置点、巡航、轨迹和透明云台的控制。SDK将云台控制分为两种模式：一种是通过图像预览返回的句柄进行控制；另一种是无预览限制，通过用户注册ID号进行云台控制。\n解码器功能模块：实现解码器设备的配置、解码控制等功能。SDK支持单路解码器和多路解码器，但目前以多路解码器为主流产品。\n智能行为分析模块：实现对智能产品的参数配置，报警上传和能力集获取等功能\n\n3.安卓如何调用摄像头拍照创建布局文件// 创建布局文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    tools:context=&quot;.MainActivity&quot;&gt;        &lt;!--用于显示预览--&gt;    &lt;SurfaceView        android:id=&quot;@+id/surfaceview&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot; /&gt;    &lt;!--LinearLayout线性布局管理器 放在父容器底部--&gt;    &lt;!--LinearLayout线性布局管理器 内部水平分布--&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_alignParentBottom=&quot;true&quot;        android:orientation=&quot;horizontal&quot;        android:gravity=&quot;center_horizontal&quot;&gt;        &lt;Button            android:id=&quot;@+id/take_photo&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;拍照&quot; /&gt;        &lt;Button            android:id=&quot;@+id/preview&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;打开摄像头&quot; /&gt;            &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt;\n\n主函数方法1.这里调用了Camera 的类2.声明一个布尔型变量ispreview，用来判断摄像头是否打开\n//写在开始部分  private Camera camera;  private boolean ispreview = false;\n\n3.设置全屏显示\n //写在onCreat方法里面getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,               WindowManager.LayoutParams.FLAG_FULLSCREEN);\n\n4.获取SurfaceView,SurfaceHolder\n//写在onCreat方法里面   final SurfaceView surface = findViewById(R.id.surfaceview);//获取surfaceview      final SurfaceHolder surfaceHolder = surface.getHolder();//获取suafaceholder      surfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);\n\n5.获取监听预览按钮\n //写在onCreat方法里面Button preview = findViewById(R.id.preview);       preview.setOnClickListener(new View.OnClickListener() &#123;           @Override           public void onClick(View v) &#123;               if (!ispreview) &#123;//如果没打开                   camera = Camera.open();//打开摄像头                   ispreview = true;               &#125;               try &#123;                   camera.setPreviewDisplay(surfaceHolder);//设置预览                   Camera.Parameters parameters = camera.getParameters();//获取摄像头参数                   parameters.setPictureFormat(PixelFormat.JPEG);//设置图片为jpg                   parameters.set(&quot;jpeg-quality&quot;, 80);//设置图片质量                   camera.setParameters(parameters);//重新设置摄像头参数                   camera.startPreview();//开始预览                   camera.setDisplayOrientation(90);//不加的话，预览的图像就是横的                   camera.autoFocus(null);//自动对焦               &#125; catch (IOException e) &#123;                   e.printStackTrace();               &#125;           &#125;       &#125;);\n\n6.拍照\n//写在onCreat方法里面Button take_photo = (Button)findViewById(R.id.take_photo);//获取按钮take_photo.setOnClickListener(new View.OnClickListener() &#123;//监听          @Override          public void onClick(View v) &#123;              if (camera != null) &#123;                  camera.takePicture(null, null, jpeg);              &#125;          &#125;      &#125;);\n\n7.存储图像\n//写在onCreat方法外面final Camera.PictureCallback jpeg = new Camera.PictureCallback() &#123;      @Override      public void onPictureTaken(byte[] data, Camera camera) &#123;          Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);          //根据拍照得到的数据集创建位图          camera.stopPreview();          ispreview = false;          File appDir = new File(Environment.getExternalStorageDirectory(), &quot;/DCIM/Camera/&quot;);          if (!appDir.exists()) &#123;//如果目录不存在              appDir.mkdir();//创建目录          &#125;          String filename = System.currentTimeMillis() + &quot;.jpg&quot;;          File file = new File(appDir, filename);          try &#123;              FileOutputStream outputStream = new FileOutputStream(file);              //创建文件输出流              bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream);              //将图片压缩成JPEG格式输出到输出流              outputStream.flush();//将缓冲区的数据都输入到输出流              outputStream.close();//关闭输出流          &#125; catch (FileNotFoundException e) &#123;              e.printStackTrace();          &#125; catch (IOException e) &#123;              e.printStackTrace();          &#125;          //将图片插入到系统图库          try &#123;              MediaStore.Images.Media.insertImage(MainActivity.this.getContentResolver(), file.getAbsolutePath(), filename, null);          &#125; catch (FileNotFoundException e) &#123;              e.printStackTrace();          &#125;          //通知图库更新          MainActivity.this.sendBroadcast(new Intent(Intent.                  ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(&quot;file://&quot;+&quot;&quot;)));          Toast.makeText(MainActivity.this,&quot;照片已存&quot;+file,Toast.LENGTH_LONG).show();          resetCamera();//图片保存后，判断，是否需要重新打开预览，重新创建一个方法，第8步      &#125;  &#125;;\n\n8.重新判定摄像头是否在预览\nprivate void resetCamera() &#123;\tif (!ispreview) &#123;    camera.startPreview();    ispreview=true;   \t&#125;&#125;\n\n9.释放摄像头资源\nprotected  void onPause() &#123;    super.onPause();    if(camera!=null)&#123;        camera.stopPreview();        camera.release();    &#125;&#125;\n\n10.从这边开始，我们就完成了整体布局，下面去manifest文件中进行权限处理路径为：app/manifes/AndroidManifest.xml ， 这是安卓布局文件\n\n增加了 摄像头权限，读写权限，自动对焦 的申请\n\n&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;    tools:ignore=&quot;ProtectedPermissions&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;&lt;uses-feature android:name=&quot;android.hardware.camera&quot;/&gt;&lt;uses-feature android:name=&quot;android.hardware.camera.autofoucs&quot;/&gt;\n\n","categories":["日常调研"],"tags":["摄像头 华为云"]}]